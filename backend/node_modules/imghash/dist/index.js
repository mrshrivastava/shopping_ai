"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var import_fs = __toESM(require("fs"));
var import_blockhash_core = __toESM(require("blockhash-core"));
var import_image = require("@canvas/image");
var import_image_type = __toESM(require("image-type"));
var import_jpeg_js = __toESM(require("jpeg-js"));
var JPEG_MAX_MEMORY_USAGE_MB = 1024;
var HEX_BINARY_LOOKUP = {
  0: "0000",
  1: "0001",
  2: "0010",
  3: "0011",
  4: "0100",
  5: "0101",
  6: "0110",
  7: "0111",
  8: "1000",
  9: "1001",
  a: "1010",
  b: "1011",
  c: "1100",
  d: "1101",
  e: "1110",
  f: "1111",
  A: "1010",
  B: "1011",
  C: "1100",
  D: "1101",
  E: "1110",
  F: "1111"
};
var BINARY_TO_HEX_LOOKUP = {
  "0000": "0",
  "0001": "1",
  "0010": "2",
  "0011": "3",
  "0100": "4",
  "0101": "5",
  "0110": "6",
  "0111": "7",
  1e3: "8",
  1001: "9",
  1010: "a",
  1011: "b",
  1100: "c",
  1101: "d",
  1110: "e",
  1111: "f"
};
async function hash(filepath, bits, format) {
  format = format || "hex";
  if (format !== "hex" && format !== "binary") {
    throw new Error(`Unsupported format: ${format}`);
  }
  bits = bits || 8;
  if (bits % 4 !== 0) {
    throw new Error(`Invalid bit-length: ${bits}`);
  }
  const fileData = await new Promise((resolve, reject) => {
    if (Buffer.isBuffer(filepath)) {
      return resolve(filepath);
    }
    import_fs.default.readFile(filepath, (err, content) => {
      if (err) return reject(err);
      resolve(content);
    });
  });
  let imageData;
  try {
    const image = await (0, import_image.imageFromBuffer)(fileData);
    imageData = (0, import_image.getImageData)(image);
  } catch (error) {
    if ((0, import_image_type.default)(fileData).mime === "image/jpeg") {
      imageData = import_jpeg_js.default.decode(fileData, {
        maxMemoryUsageInMB: JPEG_MAX_MEMORY_USAGE_MB
      });
    } else {
      throw error;
    }
  }
  const hexHash = hashRaw(imageData, bits);
  if (format === "binary") {
    return hexToBinary(hexHash);
  }
  return hexHash;
}
function hashRaw(data, bits) {
  return import_blockhash_core.default.bmvbhash(data, bits);
}
function hexToBinary(s) {
  let ret = "";
  for (let i = 0; i < s.length; i++) {
    if (Object.prototype.hasOwnProperty.call(HEX_BINARY_LOOKUP, s[i])) {
      ret += HEX_BINARY_LOOKUP[s[i]];
    }
  }
  return ret;
}
function binaryToHex(s) {
  let ret = "";
  for (let i = 0; i < s.length; i += 4) {
    const chunk = s.slice(i, i + 4);
    if (Object.prototype.hasOwnProperty.call(BINARY_TO_HEX_LOOKUP, chunk)) {
      ret += BINARY_TO_HEX_LOOKUP[chunk];
    }
  }
  return ret;
}
var api = {
  hash,
  hashRaw,
  hexToBinary,
  binaryToHex
};
module.exports = api;
